// Code generated by aocgen; DO NOT EDIT.
package year2023
import "fmt"
//import "errors"
type Day10 struct{}

type Connection struct {
	delta_x int
	delta_y int
}

type Position struct {
	x int
	y int
}

func (p Position) follow(c Connection) Position {
	return Position{p.x + c.delta_x, p.y + c.delta_y}
}

type CustomChar struct {
	char rune 
	connections []Connection
}

func NewCustomChar(char rune) CustomChar {
	if char == '.' {
		return CustomChar{char, []Connection{}}
	} else if char == '-' {
		return CustomChar{char, []Connection{Connection{1, 0}, Connection{-1, 0}}}
	} else if char == '|' {
		return CustomChar{char, []Connection{Connection{0, 1}, Connection{0, -1}}}
	} else if char == '7' {
		return CustomChar{char, []Connection{Connection{-1, 0}, Connection{0, 1}}}
	} else if char == 'L' {
		return CustomChar{char, []Connection{Connection{1, 0}, Connection{0, -1}}}
	} else if char == 'F' {
		return CustomChar{char, []Connection{Connection{1, 0}, Connection{0, 1}}}
	} else if char == 'J' {
		return CustomChar{char, []Connection{Connection{-1, 0}, Connection{0, -1}}}
	} else if char == 'S' {
		return CustomChar{char, []Connection{}}
	}

	panic("Something went wrong!")
}

func (p Day10) PartA(lines []string) any {
	all_chars := []rune{'.', '-', '|', '7', 'L', 'F', 'J', 'S'}
	chars := make(map[rune]CustomChar)
	for _, char := range all_chars {
		chars[char] = NewCustomChar(char)
	}

	s_pos := Position{-1, -1}
	mat := make([][]CustomChar, len(lines)-1)
	// read input to matrix 
	for i, line := range lines[:len(lines)-1] {
		mat[i] = make([]CustomChar, len(line))
		for j, char := range line {
			mat[i][j] = chars[char]
			if char == 'S' {
				s_pos = Position{j, i}
			}
		}
	}

	// determine pipe type of S
	s_connections := []Connection{}

	if mat[s_pos.y][s_pos.x-1].char == '-' || mat[s_pos.y][s_pos.x-1].char == 'L' || mat[s_pos.y][s_pos.x-1].char == 'F' {
		s_connections = append(s_connections, Connection{-1, 0})
	}
	if mat[s_pos.y][s_pos.x+1].char == '-' || mat[s_pos.y][s_pos.x+1].char == 'J' || mat[s_pos.y][s_pos.x+1].char == '7' {
		s_connections = append(s_connections, Connection{1, 0})
	}
	if mat[s_pos.y-1][s_pos.x].char == '|' || mat[s_pos.y-1][s_pos.x].char == '7' || mat[s_pos.y-1][s_pos.x].char == 'F' {
		s_connections = append(s_connections, Connection{0, -1})
	}
	if mat[s_pos.y+1][s_pos.x].char == '|' || mat[s_pos.y+1][s_pos.x].char == 'J' || mat[s_pos.y+1][s_pos.x].char == 'L' {
		s_connections = append(s_connections, Connection{0, 1})
	}
	if len(s_connections) != 2 {
		panic("Something went wrong!")
	}
	mat[s_pos.y][s_pos.x].connections = s_connections

	// Follow pipe from S until reaching S again and count steps
	old_pos := Position{-1, -1}
	current_pos := s_pos
	var new_pos Position
	steps := 0
	for {
		// follow pipe
		new_pos = current_pos.follow(mat[current_pos.y][current_pos.x].connections[0])
		if new_pos == old_pos {
			new_pos = current_pos.follow(mat[current_pos.y][current_pos.x].connections[1])
		}
		steps += 1

		// check if reached S again
		if new_pos == s_pos {
			break
		}
		old_pos = current_pos
		current_pos = new_pos
	}
	// return max steps away from S

	return steps/2
}




func get_all_outside_loop_positions(visited []Position, loop_positions []Position, current_pos Position, max int) ([]Position) {
	visited = append(visited, current_pos)
	var new_position Position
	for i:=-1; i<=1; i+=2 {
		for j:=0; j<2; j++ {
			if j== 0 {
				if current_pos.x+i < 0 || current_pos.x+i > max {
					continue
				} else {
					new_position = Position{current_pos.x+i, current_pos.y}
				}
			} else {
				if current_pos.y+i < 0 || current_pos.y+i > max {
					continue
				} else {
					new_position = Position{current_pos.x, current_pos.y+i}
				}
			}
			already_visited := false
			for _, pos := range visited {
				if pos == new_position {
					already_visited = true
					break
				}
			}
			if !already_visited {
				loop_pos := false
				for _, pos := range loop_positions {
					if pos == new_position {
						loop_pos = true
						break
					}
				}
				if !loop_pos {
					//fmt.Println(new_position)
					visited = get_all_outside_loop_positions(visited, loop_positions, new_position, max)
				}
			}
		}
	}
	return visited
}

func (p Day10) PartB(lines []string) any {
	all_chars := []rune{'.', '-', '|', '7', 'L', 'F', 'J', 'S'}
	chars := make(map[rune]CustomChar)
	for _, char := range all_chars {
		chars[char] = NewCustomChar(char)
	}

	s_pos := Position{-1, -1}
	mat := make([][]CustomChar, len(lines)-1)
	// read input to matrix 
	for i, line := range lines[:len(lines)-1] {
		mat[i] = make([]CustomChar, len(line))
		for j, char := range line {
			mat[i][j] = chars[char]
			if char == 'S' {
				s_pos = Position{j, i}
			}
		}
	}
	// determine pipe type of S
	s_connections := []Connection{}

	if mat[s_pos.y][s_pos.x-1].char == '-' || mat[s_pos.y][s_pos.x-1].char == 'L' || mat[s_pos.y][s_pos.x-1].char == 'F' {
		s_connections = append(s_connections, Connection{-1, 0})
	}
	if mat[s_pos.y][s_pos.x+1].char == '-' || mat[s_pos.y][s_pos.x+1].char == 'J' || mat[s_pos.y][s_pos.x+1].char == '7' {
		s_connections = append(s_connections, Connection{1, 0})
	}
	if mat[s_pos.y-1][s_pos.x].char == '|' || mat[s_pos.y-1][s_pos.x].char == '7' || mat[s_pos.y-1][s_pos.x].char == 'F' {
		s_connections = append(s_connections, Connection{0, -1})
	}
	if mat[s_pos.y+1][s_pos.x].char == '|' || mat[s_pos.y+1][s_pos.x].char == 'J' || mat[s_pos.y+1][s_pos.x].char == 'L' {
		s_connections = append(s_connections, Connection{0, 1})
	}
	if len(s_connections) != 2 {
		panic("Something went wrong!")
	}
	mat[s_pos.y][s_pos.x].connections = s_connections

	new_mat := make([][]CustomChar, len(mat)+2+len(mat)-1)
	new_mat[0] = make([]CustomChar, len(mat)+2+len(mat)-1)
	new_mat[len(new_mat)-1] = make([]CustomChar, len(mat)+2+len(mat)-1)
	for i:=0; i<len(new_mat[0]); i++ {
		new_mat[0][i] = chars['.']
		new_mat[len(new_mat)-1][i] = chars['.']
	}
	for i:=1; i<len(new_mat)-1; i++ {
		new_mat[i] = make([]CustomChar, len(mat)+2+len(mat)-1)
		new_mat[i][0] = chars['.']
		new_mat[i][len(new_mat[i])-1] = chars['.']
		for j:=1; j<len(new_mat[i])-1; j++ {
			if j % 2 == 0 {
				if i % 2 == 0 {
					new_mat[i][j] = chars['.']
				} else {
					new_mat[i][j] = chars['-']
				}
			} else if i % 2 == 0 {
				new_mat[i][j] = chars['|']
			} else {
				new_mat[i][j] = mat[i/2][j/2]
			}
		}
	}

	s_pos = Position{s_pos.x*2+1, s_pos.y*2+1}

	// Follow pipe from S until reaching S again and count steps
	old_pos := Position{-1, -1}
	current_pos := s_pos
	var new_pos Position
	steps := 0
	loop_nodes := []Position{}
	for {
		loop_nodes = append(loop_nodes, current_pos)
		// follow pipe
		new_pos = current_pos.follow(new_mat[current_pos.y][current_pos.x].connections[0])
		if new_pos == old_pos {
			new_pos = current_pos.follow(new_mat[current_pos.y][current_pos.x].connections[1])
		}
		steps += 1

		// check if reached S again
		if new_pos == s_pos {
			break
		}
		old_pos = current_pos
		current_pos = new_pos
	}
	// return max steps away from S
	return "asdf"
	current_pos = Position{0, 0}
	visited := get_all_outside_loop_positions([]Position{}, loop_nodes, current_pos, len(new_mat)-1)

	not_loop := 0
	for _, v := range visited {
		if v.x != 0 && v.y != 0 && v.x != len(new_mat)-1 && v.y != len(new_mat)-1 {
			if v.x % 2 == 1 && v.y % 2 == 1 {
				not_loop += 1
			}
		}
	}
	fmt.Println(not_loop, steps)
	return len(mat)*len(mat)-not_loop-steps/2
}
